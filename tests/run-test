#!/bin/bash
set -o errexit -o nounset -o pipefail
function -h {
cat <<USAGE
 USAGE: run-test

  Push config and code for a test run to the target servers.

USAGE
}; function --help { -h ;}                 # A nice way to handle -h and --help

function main {
  sbt assembly
  for num in {0..9}
  do init_host "$num"
  done
}

function globals {
  export LC_ALL=en_US.UTF-8                  # A locale that works consistently
  export LANG="$LC_ALL"
}; globals

function init_host {
  local num="$1"

  [[ $num != 0 ]] || num=a

  local tar=H"$num".properties.tgz
  local hostname=0"$1".netx-stats.emesos.co

  # ship the service net jar
  scp target/scala-*/service-net-assembly-*.jar \
      "$hostname":/tmp/svcnet.jar

  # ship the testing app jar to the server
  scp tests/target/scala-*/service-net-tests-assembly-*.jar \
      "$hostname":/tmp/svcnet-test.jar

  # tar up the properties files for that host and copy it to the host
  local tar=H"$num".properties.tgz
  tar czf "$tar" tests/harness/H"$num"*.properties
  scp "$tar" "$hostname":/tmp

  # copy the network doc to the host
  scp tests/harness/net.json "$hostname":/tmp

  remote "$hostname" --sudo -- run_svcnet_over_configs "$num" /tmp/"$tar"
}

function run_svcnet_over_configs {
  local num="$1" tar="$2"
  tar xzf "$tar"
  for config in tests/harness/H"$num"-*.properties
  do
    local cmd=( java -Dsvcnet.config="$config" -jar /tmp/svcnet.jar )
    { printf ' :;' ; printf ' %q' "${cmd[@]}" ; echo ;} >&2
    "${cmd[@]}" & #>"$config".log &
    local pid=$!
    ( sleep 10
      curl -X PUT http://localhost:9000/doc --data-binary @/tmp/net.json
    ) && local code=$? || local code=$?
    kill -TERM "$pid"
    [[ $code = 0 ]] || return $code
  done
}

##################################################################### Utilities

# Used like this: remote <ssh options> -- <command> <arg>*
function remote {
  local ssh=( -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no )
  local shell=( bash )
  while [[ ${1:+isset} ]]
  do
    case "$1" in
      --sudo) shell=( sudo bash ) ; shift ;;
      --)     shift ; break ;;
      *)      ssh=( "${ssh[@]}" "$1" ) ; shift ;;
    esac
  done
  serialized "$@" | ssh "${ssh[@]}" "${shell[@]}"
}

# Set up the actor on the remote end and then send it a message.
function serialized {
  declare -f
  echo set -o errexit -o nounset -o pipefail
  printf 'globals &&'
  printf ' %q' "$@" ; echo
}

function msg { out "$*" >&2 ;}
function err { local x=$? ; msg "$*" ; return $(( $x == 0 ? 1 : $x )) ;}
function out { printf '%s\n' "$*" ;}

# Handles "no-match" exit code specified by POSIX for filtering tools.
function maybe { "$@" || return $(( $? == 1 ? 0 : $? )) ;}

######################### Delegates to subcommands or runs main, as appropriate
if [[ ${1:-} ]] && declare -F | cut -d' ' -f3 | fgrep -qx -- "${1:-}"
then "$@"
else main "$@"
fi

